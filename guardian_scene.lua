--------------------------------------------------------------------------------------------- main_scene.lua-- main start screen-------------------------------------------------------------------------------------------local composer = require("composer")local scene = composer.newScene()local appID="ca-app-pub7076217142775158~9318261029" -- Asmaa accountlocal appID="cca-app-pub-1583602512170542~7824993711" -- Mahmoud accountlocal ads = require( "ads" )-- requireslocal widget = require("widget")local _G = require("global_variables")local pauseScene = _G.pauseScene ;local mainScene = _G.main_screen ;_G.init()local sounds = require("audio_files")sounds.init()local physics  = require ("physics")physics.start()--physics.setDrawMode ( "hybrid" ) -- Uncomment in order to show in hybrid modephysics.setGravity( 0, 9.8 * 2)-- [ Variable ]local variables={  lastScene = "",  space_between_bugs = _G._W/ 6,  sceneParams ={},  currentScene=_G.killScene,  optionScene={    lastScene = currentScene   },  maxPoints = 5,  gamePaused = false,  isFirstShowing = true,  currentAnchor =1 ,  current_pool_count = 10,};local status={  SPAWNED = "SPAWNED",  CRUCHED ="CRUCHED"}local arrays={  rangX={},  rangY = {},  spawnedIndexes={},}; local groups={  pauseGroup= display.newGroup(),  sceneGroup = display.newGroup(),  mainSceneGroup = display.newGroup()}local backgroundlocal scoreValuelocal levelTextlocal holelocal bugs = display.newGroup()local splashGroup = display.newGroup()local bugObjects = {}local dead_bugObjects = {}local candy ;local bug_names = { "snake_shadow", "snake_shadow", "snake_shadow", "snake_shadow" };local bug_names = { "bug4", "bug5", "bug6" };local bug_names = { "normal", "elite", "king"  };local bug_names = { "trumb1", "trumb2" ,"trumb_blue"  };local bug_names = { "red", "green" ,"blue" ,"orange","panafsg" ,"purple" ,"yellow"  };local bug_dead_names = { "normal_dead", "elite_dead", "king_dead" };local bug_dead_names_1 = { "normal_dead_1", "elite_dead_1", "king_dead_1" };local bug_dead_names_2 = { "normal_dead_2", "elite_dead_2", "king_dead_2" };local splashImgs={"splash1.png", "splash2.png", "splash3.png"};local cruch_Sounds = { sounds.crushNormal, sounds.crushElite, sounds.crushKing }--=========Spawn Datalocal spawn={  no = 1 ,  speed = 200,  delay=100}; local level= {      no =1,      spawnNumbers =5}local currentSpawnedBugsNumber =0--========= Bugs Datalocal served_points={};local served_BugsX={};local served_BugsY={};local anchors = {"topLeft" ,"topCenter" ,"topRight" , "bottomLeft","bottomCenter" , "bottomRight" }local anchors = {"topLeft" , "topRight" , "bottomLeft" , "bottomRight" }local currentSpawnedBugs={}  local minOffset = 100 ;local maxOffset = 100 ;--========= Candy Datalocal candy_weight = 100 ;local candyProp = {density = 1.0, friction = 0.3, bounce = 0.2, radius =30,--[[ filter = {categoryBits = 4, maskBits = 8}]] }--=====Mathslocal mCeil = math.ceillocal mAtan2 = math.atan2local mPi = math.pilocal mSqrt = math.sqrtlocal num_Bug = 010 ;-- Splash propertieslocal splashFadeTime = 1000local splashFadeDelayTime = 5000local splashInitAlpha = .5local splashSlideDistance = 50 -- The amoutn of of distance the splash slides down the background-- Gush filter should not interact with other fruit or the catch platformlocal gushProp = {density = 1.0, friction = 0.3, bounce = 0.2, filter = {categoryBits = 4, maskBits = 8} }-- Gush propertieslocal minGushRadius = 10local maxGushRadius = 15local numOfGushParticles = 15local gushFadeTime = 500local gushFadeDelay = 500local minGushVelocityX = -350local maxGushVelocityX = 350local minGushVelocityY = -350local maxGushVelocityY = 350-- Slash line properties (line that shows up when you move finger across the screen)local lineThickness = 10local lineFadeTime = 250local endPoints = {}local slashSounds = {slash1 = sounds.splashElite, slash2 = sounds.splashNormal, slash3 = sounds.splashKing}local slashSoundEnabled = true -- sound should be enabled by default on startuplocal minTimeBetweenSlashes = 150 -- Minimum amount of time in between each slash soundlocal minDistanceForSlashSound = 50 -- Amount of pixels the users finger needs to travel in one frame in order to play a slash sound-- Heart Datalocal HEART_INC = 4.0                     -- how fast to increment/decrement the life meterlocal HEART_HEIGHT = 100                  -- how heigh is the heart imagelocal HEART_WIDTH = 100                   -- how wide is the heart imagelocal heartPower = 100                    -- initial power on life meterlocal shakingCounter = 0 ;--Transitions local Timers = {  recalcTimer=nil,}-- [ Functions ]local Functions={    getPoint={},     hasCollided ={},    hasCollidedCircle ={},    testCollisions ={},    EatingCandy ={},    get_remove_target_Bug ={},    get_target_Bug ={},    GetRandomPoint ={},    GetRandomPoint1 ={},    ArrangeGroups ={},    checkDistance ={},    GetRandomPosition ={},    buildLevel ={},    buildBug ={},     onTouchBugEvent ={},    onTapBugEvent ={},    onSmashBug ={},    drawSlashLine ={},    StartGame={},    removeSmashListener={},    onTouchCandyEvent,    createGush ={},    getRandomSplash ={},    createSplash ={},    shakingCandy ={},    DrawHearIndicator = {},    recalculateHearIndicator={},    recalcHearIndicator={},    spawnBugs={},    spawnBug={},    bugMovement={},     bugWalking={},    gameLogic={},    removeMeFromSpawnedTable={},    checkCurrentSpawned={},    startMoving={},  }local  heartFront      local Transitions={  cancel={}}    function onStartButtonPressed( ... )            groups.mainSceneGroup = mainScene:destroyScene();      if variables.pauseGroup then          groups.sceneGroup:insert(groups.mainSceneGroup)          groups.mainSceneGroup:toFront();      end  end  function onMenuButtonPressed( ... )      print("MAIN MENU")        --_G.sceneOptions.params.lastScene = _G.killScene ;        --variables.gamePaused = false;        pauseScene:destroyScene();        groups.mainSceneGroup = mainScene.createScene();        groups.mainSceneGroup:toFront();        if groups.mainSceneGroup then            groups.sceneGroup:insert(groups.mainSceneGroup)            groups.mainSceneGroup:toFront();        end                 variables.gamePaused = false ;                 --composer.gotoScene(_G.mainScene , _G.sceneOptions)      --composer.gotoScene( _G.mainScene, _G.sceneOptions)      return true;  end    function onResumeButtonPressed(...)    if variables.gamePaused  then        variables.gamePaused = false;        pauseScene:destroyScene();        Functions.ResumeGame();    end    return true ;  end    function onRestartButtonPressed(...)        variables.gamePaused = false;    pauseScene:destroyScene();    Functions.RestartGame()     end    function Functions.RestartGame()    print("RestartGame  -------------")    score = 0 ;    scoreValue.value = score    scoreValue:setText("Score : " .. score)    for i=1 , #bugObjects do       bugObjects[i].status = "CRUCHED" ;        local point = Functions.getPoint();       bugObjects[i].x , bugObjects[i].y = point.x , point.y ;    end        Functions.StartGame();  end  function Functions.getCurrentPoolCount()    local count = 10;    for i =1 , #bugObjects do      if bugObjects[i] == "empty" then        count = count -1 ;       end       end    print("==============" .. count .. "=========")  end    function Functions.onPauseButtonRelease(...)      if (not variables.gamePaused) then          groups.pauseGroup = pauseScene.createScene();          variables.gamePaused = true;          Functions.PauseGame();          if groups.pauseGroup then              groups.sceneGroup:insert(groups.pauseGroup)              groups.pauseGroup:toFront();          end      end      return true;  end  function Functions.PauseGame( ... )    -- body       for i =1 ,  #bugObjects do          transition.pause(bugObjects[i].movingTransition );        transition.pause(bugObjects[i].walkingTransition1);        transition.pause(bugObjects[i].walkingTransition2);        if bugObjects[i].eatindTimer  then timer.pause(bugObjects[i].eatingTimer); end      end  end  function Functions.ResumeGame( ... )    if #currentSpawnedBugs > 0 then      for i =1 , #currentSpawnedBugs do         local bug = currentSpawnedBugs[i];        transition.resume(bug.movingTransition );        transition.resume(bug.walkingTransition1);        transition.resume(bug.walkingTransition2);        if bug.eatindTimer  then timer.resume(bug.eatingTimer); end      end    end  end  function Functions.pauseTransitions()   end  function Transitions.cancel(trans,type)    if trans ~= nil then      if not type then        transition.cancel(trans)      else        timer.cancel(trans)      end      trans =nil ;    end  end     -- rectangle based  function Functions.hasCollided(obj1, obj2)    if obj1 == nil then      return false    end    if obj2 == nil then      return false    end    if obj1.contentBounds == nil then      return false    end    if obj2.contentBounds == nil then      return false    end    local left = obj1.contentBounds.xMin <= obj2.contentBounds.xMin and obj1.contentBounds.xMax >= obj2.contentBounds.xMin    local right = obj1.contentBounds.xMin >= obj2.contentBounds.xMin and obj1.contentBounds.xMin <= obj2.contentBounds.xMax    local up = obj1.contentBounds.yMin <= obj2.contentBounds.yMin and obj1.contentBounds.yMax >= obj2.contentBounds.yMin    local down = obj1.contentBounds.yMin >= obj2.contentBounds.yMin and obj1.contentBounds.yMin <= obj2.contentBounds.yMax    return (left or right) and (up or down)  end  -- circle based  function Functions.hasCollidedCircle(obj1, obj2)    if obj1 == nil  and obj1 ~= "empty"then      return false    end    if obj2 == nil then      return false    end    local sqrt = math.sqrt    local dx =  obj1.x - obj2.x;    local dy =  obj1.y - obj2.y;    local distance = sqrt(dx*dx + dy*dy);         local objectSize = ((obj2.contentWidth/2) + (obj1.contentWidth/2)) * 0.75;    if distance < objectSize and obj1.isAlive and obj1.isVisible then      obj1.eating = true;      return true    end    return false  end    function Functions.testCollisions()    for i=1 ,#currentSpawnedBugs do      if  currentSpawnedBugs[i] ~= "empty" then        if Functions.hasCollidedCircle(currentSpawnedBugs[i] , candy)  then          Functions.EatingCandy(currentSpawnedBugs[i] )   ;        end      end    end  end  function Functions.recalcHearIndicator(bug_object)    local isFirst= true    local delay =1000 ;    local function calc(bug_object)      --local bug = Functions.get_target_Bug(bug_object);      local bug = bug_object ;      if isFirst then        isFirst = false ;        delay = 0;      else        delay = 1000 ;      end      --print (bug.isAlive);      if  bug and  bug.isAlive and bug.eating  then        candy.weight = candy.weight -bug.id ;        if  candy.weight <= 0 then          print("Game over")          Functions.onPauseButtonRelease();        else          Functions.recalculateHearIndicator(candy.weight)  ;          Transitions.cancel(Timers.recalcTimer ,"timer")          Timers.recalcTimer = timer.performWithDelay( delay , function() calc(bug) end  ) ;        end      end    end    calc(bug_object);  end  function Functions.EatingCandy (bug_object )     shakingCounter = 0 ; -- shakingCounter should be less than 10 to shake the flag whil bug still eating      bug_object.eatingTimer = timer.performWithDelay( 750 ,      function()        if bug_object and bug_object.isAlive and bug_object.isVisible and bug_object.movingTransition and bug_object.eating then  -- run only one time            transition.cancel(bug_object.movingTransition )            bug_object.movingTransition = nil            Functions.shakingCandy();            Functions.recalcHearIndicator(bug_object);            if   bug_object.eatingTimer ~= nil  then              Transitions.cancel(bug_object.eatingTimer , "timer")            end      end      end)  end  function Functions.shakingCandy()    local moveUp    local moveDown    local candyTrans1 = nil  ;    local candyTrans2  = nil ;    local count = 10 ;    local counter = shakingCounter ;    function moveUp()      shakingCounter = shakingCounter +1 ;      if candy and  shakingCounter < count then        if candyTrans1  then          transition.cancel(candyTrans1);          candyTrans1 =nil ;        end        candyTrans1 = transition.to(candy, { time = 50, rotation = candy.rotation + 5, onComplete = moveDown })      else        candy.rotation = 0 ;      end    end    function moveDown()      shakingCounter = shakingCounter +1 ;      if candy and  shakingCounter < count    then        if candyTrans2  then          transition.cancel(candyTrans2);          candyTrans2 =nil ;        end        candyTrans2 = transition.to(candy, { time = 50, rotation = candy.rotation - 5, onComplete = moveUp })      else        candy.rotation = 0 ;      end    end    moveUp()  end  -- Indicatore  function Functions.recalculateHearIndicator (HEART_INC)    print("AAAaaaaaaaaaaaaaaaaa")    heartPower = heartPower - HEART_INC    --[[    if ( heartPower < 0 ) then      heartPower = 0      HEART_INC = HEART_INC * -1    elseif ( heartPower > 100 ) then      heartPower = 100      HEART_INC = HEART_INC * -1    end    ]]    -- Figure out where the mask for the top image (red heart) should go    -- The mask will be centered over the object it is attached to    -- So if maskY is 0 and our mask is half black and half white    -- we would only see half of our red heart.  Since we want the heart    -- to be completely visible when the power is 100, then we need to move    -- the mid-way point up half the height of our heart    heartFront.maskY = ( HEART_HEIGHT / 2 ) - HEART_INC    -- Some more magic.  What is al???  Check out this blog entry    -- http://www.coronalabs.com/blog/2011/07/27/the-secretundocumented-audio-apis-in-corona-sdk/    -- This is changing the pitch of the background track (making it faster) each time the heart beats  end  function Functions.DrawHearIndicator()    -- Setup the spritesheet images    local heartSheetOptions =    {      frames =      {        {          x=0, y=0,          width=HEART_WIDTH, height=HEART_HEIGHT        },        {          x=125, y=0,          width=HEART_WIDTH, height=HEART_HEIGHT        }      },      sheetContentWidth = 225,      sheetContentHeight = 100    }    local scale = 0.4    -- Create the spritesheet    local heartSheet = graphics.newImageSheet(_G.IMAGE_PATH  .. "hearts.png", heartSheetOptions )    -- Setup the heart background image ( white heart )    local heartBack = display.newImage( heartSheet, 2 )    heartBack.x = _G._W*0.5 heartBack.y = _G._H*0.1    heartBack:scale(scale,scale)    groups.sceneGroup:insert(heartBack)    -- Setup the heart foreground image ( red heart )    heartFront = display.newImage( heartSheet, 1 )    heartFront.x = _G._W*0.5 heartFront.y = _G._H*0.1    heartFront:scale(scale,scale)    groups.sceneGroup:insert(heartFront)    -- Setup the mask for display the life meter    heartPower = 100                    -- initial power on life meter    local  mask = graphics.newMask(_G.IMAGE_PATH  ..  "mask.png" )    --mask:scale(0.9,0.9)    heartFront:setMask( mask )    heartFront.maskY = ( HEART_HEIGHT / 2 ) - heartPower  end  function  Functions.get_remove_target_Bug(bugObject)    local i = bugObject.i ;             bugObject.isVisible =false;    Transitions.cancel(bugObject.movingTransition);    Transitions.cancel(bugObject.walkingTransition1);    Transitions.cancel(bugObject.walkingTransition2);    bugObject.isAlive =false;    -- pushing back this bug to bugs pool    bugObjects[i] =bugObject;  end  function Functions.rePoolMe(bugObject)    local i = bugObject.i ;    bugObject.isVisible =false;        transition.cancel(bugObject.movingTransition)    bugObject.movingTransition = nil;        transition.cancel(bugObject.walkingTransition1)    bugObject.walkingTransition1 = nil;    transition.cancel(bugObject.walkingTransition2)    bugObject.walkingTransition2 = nil;          bugObject.isAlive =false;    -- pushing back this bug to bugs pool    bugObjects[i] =bugObject;    bugObjects[i].movingTransition =nil;    bugObjects[i].walkingTransition1 =nil;    bugObjects[i].walkingTransition2 =nil;    bugObjects[i].eatingTimer =nil;    --Functions.getCurrentPoolCount();    Functions.checkCurrentSpawned_V2() ;  end  function  Functions.get_target_Bug(bugObject)    local index = bugObject.i ;    local target_index ;    for i =1 , #bugObjects do      if bugObjects[i].i == index then        target_index = i ;      end    end    return(  bugObjects[target_index] );  end  function Functions.ArrangeGroups()    --candy:toBack() ;    bugs:toFront() ;    menuBtn:toFront();    levelText:toFront()    scoreValue:toFront()  end  function Functions.getPoint( ... )    -- body    variables.randAnchor = math.random(1,4); -- top =1 , right =2 ,bottom=3 , left =4    variables.randAnchor =variables.currentAnchor     variables.point ={} ;    local point={};         if variables.randAnchor == 1 then --Top      point.y = math.random(- maxOffset , -minOffset) ;      point.x = arrays.rangX[math.random(1,#arrays.rangX)];    elseif  variables.randAnchor == 2 then --Right      point.x = math.random(  _G._W +minOffset , _G._W +maxOffset ) ;      point.y = arrays.rangY[math.random(1,#arrays.rangY)];    elseif  variables.randAnchor == 3 then  -- Bottom      point.y = math.random( _G._H + minOffset ,_G._H + maxOffset ) ;      point.x = arrays.rangX[math.random(1,#arrays.rangX)];    elseif  variables.randAnchor == 4 then --Left      point.x = math.random(  -maxOffset , -minOffset ) ;      point.y = arrays.rangY[math.random(1,#arrays.rangY)];    end    variables.currentAnchor =variables.currentAnchor + 1 ;        if variables.currentAnchor > 4 then      variables.currentAnchor = 1 ;    end         return point ;  end  function Functions.GetRandomPoint( anchor)    if  anchor == "topLeft" then      local x= math.random(_G._W* -0.15 , _G._W * - 0.1);      local y = math.random(_G._H* -0.1 , _G._H *0.2);      --  local y = math.random(_G._H* 1 , _G._H * 1.1);      local point={};      point.x =x ;      point.y =y ;      return point ;    elseif  anchor == "topRight" then      local x = math.random(_G._W*1.1 , _G._W *1.15);      local y = math.random(_G._H* -0.1 , _G._H *0.2);      local point={};      point.x =x ;      point.y =y ;      return point ;    elseif  anchor == "bottomLeft" then      local x = math.random(_G._W* -0.15 , _G._W * - 0.1);      local y = math.random(_G._H*0.6 , _G._H *1.1);      local point={};      point.x =x ;      point.y =y;      return point ;    elseif  anchor == "bottomRight" then      local x= math.random(_G._W*1.1 , _G._W *1.15);      local y = math.random(_G._H*0.6 , _G._H *1.1);      local point={};      point.x =x ;      point.y =y ;      return point ;    end  end  -- getting position from outside the screenfro all directions.  function Functions.GetRandomPoint1()    local point={};    local randX = math.random( 0-maxOffset ,_G._W + maxOffset)    local randY = math.random( 0-maxOffset,_G._H + maxOffset)      if ( randX > 0 - minOffset  and randX < _G._W ) then      local rand = math.random(0,2);      if (rand == 0) then                 randY = math.random( 0 - maxOffset , 0 - minOffset ) or math.random( _G._H + maxOffset , _G._H + minOffset)      else        randY = math.random( _G._H + minOffset ,_G._H + maxOffset  ) or math.random( 0 - maxOffset , 0 - minOffset )         end    elseif ( randY > 0  and randY < _G._H) then      local rand = math.random(0,2);      if (rand == 0) then                 randX = math.random(0 - maxOffset , 0 - minOffset) or math.random(_G._W + minOffset , _G._W + maxOffset )      else        randX = math.random( _G._W + minOffset ,_G._W + maxOffset ) or math.random( _G._H + minOffset ,_G._H + maxOffset )      end           end     point.x =randX ;    point.y =randY ;    return point ;  end  function Functions.checkDistance ( point )       local dx = point.x - served_points[#served_points].x    local dy = point.y - served_points[#served_points].y    local distance = math.sqrt( dx*dx + dy*dy )    --  local objectSize = (obj2.contentWidth/2) + (obj1.contentWidth/2)    --  if ( distance < objectSize ) then      --    return true      --end      -- return false      local distanceBetween =mSqrt( ((point.y - served_points[#served_points].y) ^ 2) + ((point.x - served_points[#served_points].x) ^ 2) )      if   distanceBetween < 300 then        point = Functions.GetRandomPoint1() ;        Functions.checkDistance(point);        print(distanceBetween  .. "   Distance Between ")      else        served_points[#served_points+1] = point;      end  end  function getUniquePosition(length)    print("isUnique")    local function check(p1 , p2)      local dx = p1.x - p2.x      local dy = p1.y - p2.y      local distance = math.sqrt( dx*dx + dy*dy )             --local distanceBetween =mSqrt( ((p1.y - p2.y) ^ 2) + ((p1.x - p2.x) ^ 2) )      if   distance < 400 then         return false;      else         return true      end    end -- check function      local i =1 ;    local p1 = Functions.GetRandomPoint1();    local p2={};    p2.x ,p2.y = bugObjects[i].x , bugObjects[i].y ;    local isUnique =true;     --[[     while isUnique and i < length do       p2.x ,p2.y = bugObjects[i].x , bugObjects[i].y ;      isUnique = isUnique and check(p1 , p2) ;      i=i+1;    end    ]]    for i=1 , length   do      print("1111 isUnique")      p2.x ,p2.y = bugObjects[i].x , bugObjects[i].y ;      isUnique = isUnique and check(p1, p2)      if not isUnique then         break ;      end    end    if isUnique then      print("true")      return p1 ;    else      print("false")      return getUniquePosition(length);    end  end  function Functions.GetRandomPosition()    local point  = Functions.GetRandomPoint1();    if #served_points ~= 0 then      Functions.checkDistance( point)    else      served_points[#served_points +1] = point;    -- adding    end    return point ;  end  function Functions.creatEnemies(num_Bug)    print("Create Enemies")      bugObjects={};     for i = 1, num_Bug do      local bugIndex = math.random(1, #bug_names);      local bug_id =math.random(1,4);      local path = "res/images/bugs/live/"      local bug = display.newImageRect(_G.LIVE_BUGS_PATH  .. bug_names[bugIndex] .. "_" .. bug_id .. ".png", 160, 116);          bug.bug_id = bug_id;      bug.anchorX = 0.5;      bug.anchorY = 0.5;      bug.rotation =180 ;      bug.status = status.CRUCHED ;      --bug.isVisible = false;      bug.isAlive = false;      physics.addBody(bug, "static", candyProp )      bug.isBodyActive =true;      -- physics.addBody(bug, candyProp )      local ancIndx = math.random(1 ,#anchors) ;      if i <= #anchors then        ancIndx = i;      elseif i > #anchors and i <= #anchors *2 then        ancIndx = i - #anchors;      else        ancIndx = i - #anchors *2 ;      end      local anc = anchors[ancIndx]      --local point =  Functions.GetRandomPosition();      local point = Functions.getPoint() ;          bug.x = point.x;      bug.y = point.y;      bug.xScale = 0.4 ;      bug.yScale = 0.4 ;      bug.delay = i * 500 ;      bug.speed = i*500      bug.id = bug_id ;      bug.bug_index = bugIndex;      bug.color = bug_names[bugIndex] ;      bug.i = i ;      bug.killed_bug = nil;       bug.walkingTransition1=nil      bug.walkingTransition2=nil      bug.movingTransition = nil ;      bug.eatingTimer = nil;      bug.eating = false; -- saving initial distance between candy and bug ;      bugs:insert( bug ) ;      bug:toFront();      bugObjects[i] = bug ;       -- points -       bug.points_text = display.newText("+" .. bug.id , bug.x, bug.y, native.systemFont, 18)      bug.points_text.x = bug.x;      bug.points_text.y = bug.y ;      bug.points_text.fadingTransition = nil ;            --bug.points_text:setFillColor(0.5)      variables.color = color;      --bug.points_text:setEmbossColor(color)      bugs:insert(bug.points_text);          end  end  function Functions.StartGame( ... )    -- body    Functions.spawnBugs_V2(1) ;  end  -- remove bug from current Spawn list  function Functions.removeMeFromSpawnedTable( target )        local index = target.spawnedIndex;    table.remove(currentSpawnedBugs )    currentSpawnedBugsNumber = currentSpawnedBugsNumber -1;    Functions.checkCurrentSpawned()   end  function Functions.checkCurrentSpawned_V2()    print (#arrays.spawnedIndexes .. " arrays.spawnedIndexes")    if #arrays.spawnedIndexes <= 0 then      print("NEW ----------------- SPAWN")      spawn.no = spawn.no + 1      Functions.spawnBugs_V2(spawn.no );      --arrays.spawnedIndexes ={};    end   end  function Functions.checkCurrentSpawned()    print(currentSpawnedBugsNumber .. " currentSpawnedBugsNumber")    print(#currentSpawnedBugs .. " #currentSpawnedBugs")    if (currentSpawnedBugsNumber <= 0 and spawn.no < level.spawnNumbers )   then      currentSpawnedBugs={}      spawn.no = spawn.no + 1      Functions.spawnBugs_V2(spawn.no )    elseif( spawn.no == level.spawnNumbers )then      -- increasing the level number       level.no = level.no + 1;      levelText:setText("Level : " .. level.no)      -- resettign spawn.no to 3      spawn.no = 1 ;    end  end  -- return an available enemy, or nil if there is no enemies left  function Functions.spawnBug()      for i = 1, #bugObjects do          if not bugObjects[i].isAlive then              return bugObjects[i]          end      end      -- if we get here, there are no more available enemies in the pool      return nil  end     -- return an available enemy, or nil if there is no enemies left  --[[   function Functions.spawnBugs1(noOfSpawnedBugs)    local no = 0      for i = 1, #bugObjects do        print(bugObjects[i].isAlive )      end      for i = 1, #bugObjects do          if  not bugObjects[i].isAlive and no < noOfSpawnedBugs then            local index = bugObjects[i].i ;             no = no + 1;            bugObjects[i].isAlive = true ;            bugObjects[i].spawnedIndex = no ;            bugObjects[i].eating = false;             -- adding it to spawned array            currentSpawnedBugs[#currentSpawnedBugs + 1] = bugObjects[i] ;            currentSpawnedBugsNumber = currentSpawnedBugsNumber +1;            print(currentSpawnedBugsNumber .. " currentSpawnedBugsNumber")            print(#currentSpawnedBugs .. " #currentSpawnedBugs")                      end      end       Functions.startMoving();      print("after spawning")      for i = 1, #bugObjects do        print(bugObjects[i].isAlive )      end  end  ]]  function Functions.spawnBugs_V2 (noOfSpawnedBugs)        arrays.spawnedIndexes={};    if (spawn.no == 1 ) then      noOfSpawnedBugs = 1 ;    end    local indexes={}     for i=1 , #bugObjects do        indexes[i] = i    end    local no = 0    while #arrays.spawnedIndexes < noOfSpawnedBugs  and #indexes > 0 do             -- getting random index       --print(#indexes .. "  #indexes")      local index = math.random(1,#indexes)      local i = indexes[index];      table.remove(indexes,index);      if bugObjects[i].status == status.CRUCHED then        local Bug = bugObjects[i]        Bug.status = status.SPAWNED;        no = no +1;         Bug.isAlive = true ;        Bug.isVisible = true ;        Bug.spawnedIndex = no ;        Bug.distance = _H;         arrays.spawnedIndexes[#arrays.spawnedIndexes + 1] = Bug.i ;        function Bug.enterFrame(self)          --print(self.i);          if Functions.hasCollidedCircle(self , candy)  and not variables.gamePaused then              self.eating = true;              Functions.EatingCandy(self )   ;          else            self.eating =false;           end        end        Runtime:addEventListener("enterFrame", Bug);      end    end     print(#arrays.spawnedIndexes .. "  arrays.spawnedIndexes ----------------SPAWN BUGS-----")       Functions.startMoving_V2();      end  function Functions.spawnBugs (noOfSpawnedBugs)    if (spawn.no == 1 ) then      noOfSpawnedBugs = 1 ;    end    local indexes={}     for i=1 , #bugObjects do        indexes[i] = i    end    local no = 0    while no < noOfSpawnedBugs  and #indexes > 0 do             -- getting random index       --print(#indexes .. "  #indexes")      local index = math.random(1,#indexes)      local i = indexes[index];      table.remove(indexes,index);            if bugObjects[i] ~= "empty" then        local Bug = bugObjects[i]        bugObjects[i] = "empty"        no = no + 1;        Bug.isAlive = true ;        Bug.isVisible = true ;        Bug.spawnedIndex = no ;        Bug.distance = _H;         -- adding it to spawned array        currentSpawnedBugs[#currentSpawnedBugs + 1] = Bug ;        currentSpawnedBugsNumber = currentSpawnedBugsNumber +1;        function Bug.enterFrame(self)          --print(self.i);          if Functions.hasCollidedCircle(self , candy)  and not variables.gamePaused then              self.eating = true;              Functions.EatingCandy(self )   ;          else            self.eating =false;           end        end        Runtime:addEventListener("enterFrame", Bug)      end     end    for i= 1 , #bugObjects do      if bugObjects[i] ~= "empty" then        print("-----------------------" .. i);      else        print("---------empty--------------" .. i);      end     end         Functions.startMoving();      end  function Functions.startMoving_V2()      for i=1 , #arrays.spawnedIndexes do          local bugIndex = arrays.spawnedIndexes[i];          -- getting random position and moving it toward of flag          --local point = Functions.GetRandomPosition();          local point = Functions.getPoint();          bugObjects[bugIndex].x ,bugObjects[bugIndex].y = point.x ,point.y          Functions.bugMovement(bugObjects[bugIndex] ,750 * i);          Functions.bugWalking(bugObjects[bugIndex])          Functions.gameLogic(bugObjects[bugIndex])      end        end  function Functions.startMoving()          for i = 1, #currentSpawnedBugs do          -- getting random position and moving it toward of flag          --local point = Functions.GetRandomPosition();          local point = Functions.getPoint();          currentSpawnedBugs[i].x ,currentSpawnedBugs[i].y = point.x ,point.y          Functions.bugMovement(currentSpawnedBugs[i] ,750 * i);          Functions.bugWalking(currentSpawnedBugs[i])          Functions.gameLogic(currentSpawnedBugs[i])      end  end  -- upon death of enemy, back to the pool  local function killEnemy(enemy)     enemy.isBodyActive = false     enemy.isVisible = false     enemy.isAlive = false     --[[       --get enemy from the pool and activate it      local enemy = spawnEnemy()      if enemy ~= nil then          enemy.x = 100          enemy.y = 100          enemy.isVisible = true          enemy.isAlive = true          enemy.isBodyActive = true      end    ]]  end  local function  fillingPositionsRanges( ... )      ---------------------    local start = -1 * maxOffset ;    local end_x = _G._W + maxOffset ;    local end_y = _G._H + maxOffset;    local x = start ;     local y =start ;     while x <= end_x do       arrays.rangX[#arrays.rangX +1] = x ;       x = x + variables.space_between_bugs ;           end    while y <= end_y do       arrays.rangY[#arrays.rangY +1] = y ;       y = y+ variables.space_between_bugs ;           end        end  function Functions.buildLevel(...)    candy =  display.newImageRect(_G.IMAGE_PATH .. "cake1.png", 98, 98);    -- candy =  display.newImageRect(_G.IMAGE_PATH .. "candy.png", 98, 98);    candy.anchorX = 0.5;    candy.anchorY = 0.5;    candy.x = _G.halfW ;    candy.y =  _G.halfH ;    print (candy.x .. "    X" )    print (candy.y .. "    Y" )    print ( candy.contentBounds.xMin .. "    xMin" )    candy.weight = candy_weight;    groups.sceneGroup:insert( candy ) ;    candy:addEventListener("touch", Functions.onTouchCandyEvent)    -- Set up collisions    physics.addBody(candy, "static", candyProp )    candy.isBodyActive =true;     fillingPositionsRanges();     Functions.creatEnemies(num_Bug);     Functions.DrawHearIndicator();  end  function Functions.buildBug(...)    local bug ;    local bugIndex = math.random(1, #bug_names);    bug = display.newImageRect(_G.IMAGE_PATH .. bug_names[bugIndex] .. ".png", 160, 149);    bug.anchorX = 0.5;    bug.anchorY = 0.5;    bug.x = _G.halfW * bugIndex;    -- bug.y = _G.halfH ;    -- bug.x = math.random(0, _G._W * 4)  ;    bug.y = -100 ;    bug.movingTransition = nil ;    bugs.xScale = 0.4 ;    bugs.yScale = 0.4 ;    bug.id = bugIndex ;    bug.i = #bugObjects + 1  ;    bug._1 = bug_dead_names_1[bugIndex] ;    bug._2 = bug_dead_names_2[bugIndex] ;    bugs:insert( bug ) ;    bug:toFront();    bugObjects[#bugObjects + 1] = bug ;    return bug  ;  end  function Functions.bugWalking(bugObject)    local target = bugObject    local moveUp    local moveDown    function moveUp( bug)      if bug   then        Transitions.cancel(bug.walkingTransition1)          bug.walkingTransition1 = transition.to(bug, { time = 50, rotation = target.rotation + 5, onComplete = function() moveDown(bug) ;end })      end    end    function moveDown(bug)      if bug then        Transitions.cancel(bug.walkingTransition2)        bug.walkingTransition2 = transition.to(bug, { time = 50, rotation = target.rotation - 5, onComplete = function() moveUp(bug) ;end  })      end    end    moveUp( target )  end   function Functions.bugMovement(bugObject, delayTime)    local target = bugObject    local id = target.id ;    local _delay = delayTime    local _X = candy.x  ;    local _Y = candy.y  ;    local _TIME = math.random(_G.gameSpeed * 1000, _G.gameSpeed * 2000)    local _TIME = math.random(bugObject.speed, _G.gameSpeed * 2000)    local _TIME =   spawn.speed*100/spawn.no    local _delay = math.random(100 , 500)         --_delay = target.spawnedIndex * spawn.no * spawn.delay *10    if target.spawnedIndex ==1 then      _delay=0;    end    --_delay = math.random(100 , 500)     local x = target.x ; local y = target.y ;    target.rotation = 180;    local angleBetween = mCeil(mAtan2( (_Y - y), (_X - x) ) * 180 / mPi) +90 ; -- Look Up angle    target.rotation = angleBetween    ;    local function move(target)      local bugIndex = target.id;      --target =  Functions.get_target_Bug(target);      Transitions.cancel(target.movingTransition);      if  not target.movingTransition then        target.movingTransition = transition.to(target, { time = _TIME, delay =  _delay, x = _X, y = _Y ,          onStart =function() print(target.i .."Starting Move") end })      end    end    move(target)  end  function Functions.removeBug(bug)      if (bug ~= nil and bug ~= "empty") then        local  i = bug.i;        -- stoping moving         if( bug.movingTransition ~= nil) then          transition.cancel(bug.movingTransition)          bug.movingTransition = nil        end        Runtime:removeEventListener("enterFrame", bug)        -- Removing point_text        if  bug.points_text ~= nil then          local trans = bug.points_text.fadingTransition ;          if trans ~= nil then            Transitions.cancel(trans);          end          bug.points_text.alpha =0;          bug.points_text:removeSelf();          bug.points_text=nil;                 end        bug:removeSelf();        bugObjects[i]= nil;      end    end  function Functions.destroyGame( ... )    -- body    print("Functions.destroyGame------------------------")     --getting back spawned bugs to bugObjects array      while #currentSpawnedBugs > 0 do        local bug = currentSpawnedBugs[#currentSpawnedBugs];        bugObjects[bug.i] = currentSpawnedBugs[#currentSpawnedBugs];        table.remove( currentSpawnedBugs , #currentSpawnedBugs )      end      currentSpawnedBugs ={};      currentSpawnedBugsNumber =0;         for i = 1, #bugObjects do       if (bugObjects[i] ~= nil and bugObjects[i] ~= "empty") then        -- stoping moving         if( bugObjects[i].movingTransition ~= nil) then          transition.cancel(bugObjects[i].movingTransition)          bugObjects[i].movingTransition = nil        end        Runtime:removeEventListener("enterFrame", bugObjects[i])        -- Removing point_text        if  bugObjects[i].points_text ~= nil then          local trans = bugObjects[i].points_text.fadingTransition ;          if trans ~= nil then            Transitions.cancel(trans);          end          bugObjects[i].points_text.alpha =0;                  end        bugObjects[i]:removeSelf();        bugObjects[i]= nil;      end    end    bugObjects={};    Transitions.cancel(Timers.recalcTimer ,"timer")  end  function Functions.gameLogic(displayObject)    local target = displayObject    target:addEventListener("touch", Functions.onTouchBugEvent)    -- target:addEventListener("tap", Functions.onTapBugEvent)  end  -- Creates a gushing effect that makes it look like juice is flying out of the fruit  function Functions.createGush(x , y)    local i    for  i = 0, numOfGushParticles do      local gush = display.newCircle(  x,  y, math.random(minGushRadius, maxGushRadius) )      gush.anchorX = 0.5;      gush.anchorY = 0.5;      gush.x = x;      gush.y = y;      gush:setFillColor(255, 0, 0, 255)      gushProp.radius = gush.width / 2      physics.addBody(gush, "dynamic", gushProp)      local xVelocity = math.random(minGushVelocityX, maxGushVelocityX)      local yVelocity = math.random(minGushVelocityY, maxGushVelocityY)      gush:setLinearVelocity(xVelocity, yVelocity)      transition.to(gush, {time = gushFadeTime, delay = gushFadeDelay, width = 0, height = 0, alpha = 0, onComplete = function(event) gush:removeSelf() end})      bugs:insert(gush)    end  end  function Functions.getRandomSplash()    return display.newImage(_G.IMAGE_PATH .. splashImgs[math.random(1, #splashImgs)])  end  function Functions.createSplash(bug)    local splash = Functions.getRandomSplash();    splash.anchorX = 0.5;    splash.anchorY = 0.5;    splash.x = bug.x;    splash.y = bug.y;    splash.rotation = math.random(-90,90)    splash.alpha = splashInitAlpha    bugs:insert(splash)    splash:toBack();    transition.to(splash, {time = splashFadeTime, alpha = 0,  y = splash.y + splashSlideDistance, delay = splashFadeDelayTime, onComplete = function(event) splash:removeSelf() end})  end  function Functions.remove_Me( bugObject )    local removing_Timer = timer.performWithDelay(1000 ,function() bugObject:removeSelf(); end)   end  function  Functions.getIndex( value  )    -- body        print(#arrays.spawnedIndexes .. "Get Index x-------------------")    for i=1 , #arrays.spawnedIndexes do      if arrays.spawnedIndexes[i] == value then        return i ;      end    end  end  function Functions.cruch_Me1(bugObject)    local target = bugObject;    local bug_id = target.id;    local bugIndex = target.bug_index;    local dead_bug = display.newImageRect(_G.KILLED_BUGS_PATH .. bug_names[bugIndex] .. "_" .. bug_id .. ".png", 160, 158);    dead_bug.anchorX = 0.5;    dead_bug.anchorY = 0.5;    dead_bug.x = target.x;    dead_bug.y = target.y;    dead_bug.rotation = target.rotation;    dead_bug:scale(0.8,0.8);    dead_bug.xScale = target.xScale ;    dead_bug.yScale = target.xScale;    dead_bug.id = target.id;    bugs:insert(dead_bug);    dead_bug:toBack();    target.status = status.CRUCHED ;    -- remove it from spawnedIndex array     local indexxx = Functions.getIndex(target.i ) ;    print(indexxx .. "     indexxx")    table.remove(arrays.spawnedIndexes ,indexxx );    --arrays.spawnedIndexes[indexxx] = nil ;    print(#arrays.spawnedIndexes .. " arrays.spawnedIndexes  --------- cruch_Me1")    --- points     target.points_text.x = target.x;    target.points_text.y = target.y;    target.points_text.alpha = 1 ;    target.points_text:toFront() ;    --target.points_text.fadingTransition = transition.fadeOut( target.points_text,{time = 750 , alpha = 0 } )    target.points_text.fadingTransition = transition.to(target.points_text,{time = 750 , xScale = 2 , yScale =2 ,y = target.y - 100 ,onComplete = function ()      -- body        Transitions.cancel(target.points_text.fadingTransition);        target.points_text.alpha = 0 ;        end     });    dead_bugObjects[#dead_bugObjects + 1] = bug   ;    Functions.remove_Me(dead_bug) ;    -- target:removeSelf();  end  function Functions.cruch_Me(bugObject , touchType)    local target = bugObject    local bugIndex = target.id;    local x = target.x;    local y = target.y;    if touchType == "touch" then          elseif touchType == "tap" then      Functions.cruch_Me1(target)    end      ----------------------------    target.isAlive =false    --Functions.get_remove_target_Bug(target);    Functions.rePoolMe(target);    --Functions.removeMeFromSpawnedTable(target)    Functions.createSplash(target)    Functions.createGush(x , y );    ------------------------------------------   end  function Functions.backListener( event )    -- body    if event.phase == "began" then      --Functions.removeSmashListener();        --Functions.destroyGame();    elseif  event.phase == "ended" then      variables.optionScene.lastScene = variables.currentScene ;      _G.sceneOptions.params.lastScene = variables.currentScene ;      --composer.gotoScene(_G.mainScene , _G.sceneOptions)     Functions.onPauseButtonRelease();    end    return true;  end  --***************************************************  function Functions.saveValue(strFilename, strValue)    -- will save specified value to specified file    local theFile = strFilename    local theValue = strValue    local path = system.pathForFile(theFile, system.DocumentsDirectory)    -- io.open opens a file at path. returns nil if no file found    local file = io.open(path, "w+")    if file then      -- write game score to the text file      file:write(theValue)      io.close(file)    end  end  --***************************************************  -- loadValue() --> load saved value from file (returns loaded value as string)  --***************************************************  function Functions.loadValue(strFilename)    -- will load specified file, or create new file if it doesn't exist    local theFile = strFilename    local path = system.pathForFile(theFile, system.DocumentsDirectory)    -- io.open opens a file at path. returns nil if no file found    local file = io.open(path, "r")    if file then      -- read all contents of file into a string      local contents = file:read("*a")      io.close(file)      return contents    else      -- create file b/c it doesn't exist yet      file = io.open(path, "w")      file:write("0")      io.close(file)      return "0"    end  end  function Functions.removeSmashListener( ... )    -- body    for i =0 , num_Bug do      local bug = bugObjects[i] ;      if (bug ~= nil) then        --bug:removeEventListener("touch", Functions.onTouchBugEvent);      end    end  end  function Functions.onSmashBug( bug , touchType )    if  not variables.gamePaused then        bug:removeEventListener("touch", Functions.onTouchBugEvent)        bug.isBodyActive =false;        -- bug:removeEventListener("tap", Functions.onTapBugEvent)        local id = bug.id;        Functions.cruch_Me(bug ,touchType);        --audio.play( sounds.crushNormal)        audio.play(cruch_Sounds[id])        audio.setVolume(0.5, { channel = 2 }) -- set the volume on channel 1        audio.play(sounds.crushNormal, { channel = 2, loops = 0 });        local score = tonumber(scoreValue.value)        score = score + id;        scoreValue.value = score        scoreValue:setText("Score : " .. score)    end  end  -- Draws the slash line that appears when the user swipes his/her finger across the screen  function Functions.drawSlashLine(event)    -- Play a slash sound    if(endPoints ~= nil and endPoints[1] ~= nil) then      local distance = math.sqrt(math.pow(event.x - endPoints[1].x, 2) + math.pow(event.y - endPoints[1].y, 2))      if(distance > minDistanceForSlashSound and slashSoundEnabled == true) then        slashSoundEnabled = false        timer.performWithDelay(minTimeBetweenSlashes, function(event) slashSoundEnabled = true end)      end    end    -- Insert a new point into the front of the array    table.insert(endPoints, 1, {x = event.x, y = event.y, line= nil})    -- Remove any excessed points    if(#endPoints > variables.maxPoints) then      table.remove(endPoints)    end    for i,v in ipairs(endPoints) do      local line = display.newLine(v.x, v.y, event.x, event.y)      line.strokeWidth = lineThickness      transition.to(line, {time = lineFadeTime, alpha = 0, strokeWidth = 0, onComplete = function(event) line:removeSelf() end})    end    if(event.phase == "ended") then      while(#endPoints > 0) do        table.remove(endPoints)      end    end  end  --- Touching  function Functions.onTouchCandyEvent (event )    if event.phase == "ended" then      Functions.shakingCandy();      candy.weight = candy.weight - 1    end    return true  end  function Functions.onTouchBugEvent(event )    if event.phase == "ended" then      local x,y , sX ,sY ;      x = event.x ; y = event.y ;      sX = event.xStart ; sY = event.yStart ;      local offsetX =math.abs( x - sX );      local offsetY =math.abs( y - sY );      if offsetX > 10  or offsetY > 10 then        -- Functions.onSmashBug( event.target , "touch")      else        Functions.onSmashBug( event.target , "tap")      end    end    return true  end  function onTapBugEvent(event )    Functions.onSmashBug( event.target , "tap" )    return true  end   function Functions.addMob( ... )    -- body    local appID="cca-app-pub-1583602512170542~7824993711" -- Mahmoud account    local bannerAppID = "ca-app-pub-7076217142775158/7701927020"  -- ASMAA account for your Android banner    local bannerAppID = "ca-app-pub-1583602512170542/9301726912"  -- Mahmoud account for your Android banner    local interstitialAppID = "ca-app-pub-nnnnnnnnnnn/nnnnnnnn"    if ( system.getInfo( "platformName" ) == "Android" ) then        appID = appID        bannerAppID = bannerAppID    end         local adProvider = "admob"    local function adListener( event )        --(more on this later)        -- The 'event' table includes:        -- event.name: string value of "adsRequest"        -- event.response: message from the ad provider about the status of this request        -- event.phase: string value of "loaded", "shown", or "refresh"        -- event.type: string value of "banner" or "interstitial"        -- event.isError: boolean true or false             local msg = event.response        -- Quick debug message regarding the response from the library        print( "Message from the ads library: ", msg )             if ( event.isError ) then          scoreValue.text = "Error" .. msg             print( "Error, no ad received", msg )        else             local bannerHeight = ads.height()  -- Get the loaded banner's height            --scoreValue.text = bannerHeight ..  " banner"             -- Show the banner ad with a 30 pixel gap between the screen bottom           -- ads.show( "banner", { y = _H - bannerHeight - 30 } )        end    end    local ad_Y = display.screenOriginY+display.actualContentHeight-45;    ads.init( adProvider, appID, adListener )    ads.show( "banner", { x=0, y=ad_Y , appId=bannerAppID } )    --ads.show( "interstitial", { appId=interstitialAppID } )    --local ad = display.newRect( 0, _H , _W, 80 )  end  -- "scene:create()"  function scene:create(event)    print("Create Kill Scene --------------------------")    if event.params ~= nil  then        variables.sceneParams = event.params    end    groups.sceneGroup = self.view    background = display.newImageRect(_G.IMAGE_PATH .. "level_background.png", _G._W, _G._H)    background.anchorX = 0    background.anchorY = 0    background.x = 0    background.y = 0    hole = display.newImageRect(_G.IMAGE_PATH .. "hole.png", _G._W, 50)    hole.anchorX = 0    hole.anchorY = 0    hole.x = 0    hole.y = 0    scoreValue = display.newEmbossedText("0", _G.halfW * 1.55, 15, native.systemFont, 18)    scoreValue:setFillColor(0.5)    scoreValue:setText("Score : " .. "0")    scoreValue.value = 0;    local color =    {      highlight = { r = 1, g = 1, b = 1 },      shadow = { r = 0.3, g = 0.3, b = 0.3 }    }    variables.color = color;    scoreValue:setEmbossColor(color)   --    levelText = display.newEmbossedText("Level : " ..level.no, _G.halfW*0.6 , 15, native.systemFont, 18)    levelText:setFillColor(0.5)    levelText:setText("Level : " ..level.no)    local color =    {      highlight = { r = 1, g = 1, b = 1 },      shadow = { r = 0.3, g = 0.3, b = 0.3 }    }    levelText:setEmbossColor(color)     -- Menu Button    menuBtn = display.newImageRect( "res/images/ui/menu_button.png", 64, 64 )    menuBtn.x = _G._W*0.1    menuBtn.y = _G._H*0.05    menuBtn:scale(0.7,0.7)    menuBtn.name = name    menuBtn:addEventListener( "touch", Functions.backListener )    ---Adding objects to group    groups.sceneGroup:insert(background) ;    groups.sceneGroup:insert(bugs) ;    groups.sceneGroup:insert(hole) ;    groups.sceneGroup:insert(scoreValue) ;    groups.sceneGroup:insert(menuBtn) ;    groups.sceneGroup:insert(levelText) ;    Functions.addMob();  end  -- "scene:show()"  function scene:show(event)    groups.sceneGroup = self.view    local phase = event.phase    print("Show Kill Scene --------------------------")    if (phase == "will") then      -- Called when the scene is still off screen (but is about to come on screen).              elseif (phase == "did") then      -- Called when the scene is now on screen.      -- Insert code here to make the scene come alive.      -- Example: start timers, begin animation, play audio, etc.          if variables.sceneParams ~= nil then          local params = variables.sceneParams ;          local lastScene =params.lastScene;          if lastScene ~= nil and lastScene ~= "" then              --composer.removeHidden() ;  -- Completely removes all scenes except for the currently active scene              --composer.removeScene(lastScene);          end      end      Functions.buildLevel();      Functions.StartGame();      Functions.ArrangeGroups();    end  end  -- "scene:hide()"  function scene:hide(event)    local sceneGroup = self.view    local phase = event.phase    print("Hide Kill Scene --------------------")    if (phase == "will") then      -- Called when the scene is on screen (but is about to go off screen).      -- Insert code here to "pause" the scene.      -- Example: stop timers, stop animation, stop audio, etc.    elseif (phase == "did") then      -- Called immediately after scene goes off screen.      --Functions.destroyGame();     end  end  -- "scene:destroy()"  function scene:destroy(event)    local sceneGroup = self.view    print("Destroy Kill Scene --------------------------")    --Functions.destroyGame();     -- Called prior to the removal of scene's view ("sceneGroup").    -- Insert code here to clean up the scene.    -- Example: remove display objects, save state, etc.  end    -- -------------------------------------------------------------------------------    -- Listener setup    scene:addEventListener("create", scene)    scene:addEventListener("show", scene)    scene:addEventListener("hide", scene)    scene:addEventListener("destroy", scene)    -- -------------------------------------------------------------------------------    return scene